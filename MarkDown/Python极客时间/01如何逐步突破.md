# 01 | 如何逐步突破，成为Python高手？
https://time.geekbang.org/column/article/94311
- 不同的语言，需融汇贯通
    - 你了解你学过的每种编程语言的特点嘛？
    - 你能根据不同的产品需求，选用合适的编程语言吗？
- 唯一语言，可循环渐进
    - 第一步 大厦之基，勤加练习
    - 第二步 代码规范，必不可少
    - 第三步 开发经验，质的突破
![python发展](https://static001.geekbang.org/resource/image/2c/1d/2cfc18adf51b61ca8140561071d20c1d.png)

# 02 | Jupyte NoteBook 为什么是现代的Python必学技术？
https://time.geekbang.org/column/article/94929
- 什么是jupyter ?  
ju，Py，R  
- jupyter 的影响力？  
- jupyter 的优点
    - 整合所有资源
    - 交互性编程体验
    - 零成本重现结果
- Jupyter Notebook

- Binder   
网址：https://gke.mybinder.org/ (拉去整个github项目)
    - jupyter 官网 (https://mybinder.org/v2/gh/binder-examples/matplotlib-versions/mpl-v2.0/?filepath=matplotlib_versions_demo.ipynb)
    - Google Research 提供Colab环境 (https://colab.research.google.com/notebooks/basic_features_overview.ipynb)
    - 如何你想在本地或者远程的机械上安装jupyter 参考如下文档
        - 安装：(https://jupyter.org/install.html)
        - 运行：(https://jupyter.readthedocs.io/en/latest/running.html#running)

# 03 | 列表和元组，到底用哪一个？
https://time.geekbang.org/column/article/94972
## 列表和元组基础
1:列表和元组，可以放置任意数据类型的有序集合
```python
l = [1, 2, 'hello', 'world']
l
[1, 2, 'hello', 'world']
tup = ('json', 22) 
tup
('json', 22)
```

2: 列表是动态的，长度大小不固定，可以随意的增加，删除或者改变元素.  
3：元组是静态的，长度大小固定，无法增加删除或者修改。
4: 列表和元组都支持复数索引，切片，可以随意嵌套，两者可以通过list() 和tuple() 函数相互转换。
5：内置函数
    count(),index(),reverse(),sort()(元组没有reverse()和sort()), reverse(), sorted() (表示已经倒转和排序好的列表和元组)  
6: 列表
append() and so on
7:列表和元组的使用场景
- 如果存储的数据数量不变，比如有一个函数，需要返回的是一个地点的及维度，然后直接传给前端渲染，那么肯定选用元组
```python
def get_location():
    ....
    return (longitude, latitude)
```
- 如果存储的数据数量是可变的，比如社交平台的一个日志功能，是统计一个用户在一周之内看了那些用户的帖子，那么则用列表合适。
```python
viewer_owne_id_list =  []
records = queryDB(viewer_id)
for record in record:
    viewer_owner_id_list.append(record.id)
```

8:思考题
- 创建一个空的列表，我们可以用下面A.b两种方式，请问他们在效率上有什么区别嘛?我们应该优先考虑使用哪种呢？
```python
# 创建空列表
# option A 
empty_list = list()

# option B
empty_list = []
```
1. list和tuple的内部实现都是array的形式，list因为可变，所以是一个over-allocate的array，tuple因为不可变，所以长度大小固定。具体可以参照源码list: https://github.com/python/cpython/blob/master/Objects/listobject.c. tuple: https://github.com/python/cpython/blob/master/Objects/tupleobject.c
2. 最后的思考题：
区别主要在于list()是一个function call，Python的function call会创建stack，并且进行一系列参数检查的操作，比较expensive，反观[]是一个内置的C函数，可以直接被调用，因此效率高。
内存分配，GC等等知识会在第二章进阶里面专门讲到。

- 你平时学习中，是在什么场景下使用列表和元组？
# 04 | 字典、集合，你真的了解吗？
https://time.geekbang.org/column/article/95521

# 05 | 深入浅出的字符串
https://time.geekbang.org/column/article/95897
## 字符串基础
1：' ', " ", """ """(多用于多行注释)  
2：len(s)  
3：字符串的常用操作  
- 索引 name[2]
- 切片 name[1:3]
- 修改字符串
    - s = 'H' + s[1:]
    - s = s.replace('h', 'H')
- 连接 
    - str += str2 ----> str = str + str2
- 复杂度
```python
s = ''
for n in range(0, 10000)
    s += str(n)
```
O(n^2)
- 分割
    - string.split()
    - string.lsplit()
    - string.rsplit()
- 格式化   
string.format()

## 总结
- python 中字符串使用单引号、双引号、三引号表示，三者意义相同，并没有什么区别，其中三引号的字符串通常用在多行字符串的场景。  
- Python中字符串的值是不能改变的（新版本中的+=例外）所以，随意改变字符串中的值，是不被允许的。   
- python 2.5 ，字符串的拼接变得比以前高效了许多。  
- Python中字符串的格式化(string.format) 常常用在输出、日志的记录等场景。  
## 思考题
python 2.5+,那个更优。
```python
s = ''
for n in range(1, 10000)
    s += str(nd)
```

```python
l = []
for n in range(0, 10000)
    l.append(str(n))
s = ''.join(l)
```
解：大于range(100),方法一更优，否则，方法二更优，这里提出一个更好的方式，`s = "".join(map(str, range(0, 100000))`

# 06 | Python "黑箱": 输入与输出
https://time.geekbang.org/column/article/96570
## 基本的输入输出
1：input("Notes To Say Something!")  
2：数据类型转换是使用try，catch语句。  

## 简单NLP（自然语言处理）任务。
- 基本步骤
    - 1:读取文件
    - 2:去除所有标点和换行符，并把所有大写转换成小写
    - 3:合并相同的词，统计每个词出现的频率，并按照词频从大到小排序
    - 4:将结果输出到文件out.txt
```python
import re


def parse(text):
    # 使用re去除标点和换行符
    text = re.sub(r'[^\w]', ' ', text) # sub 函数用于替换字符串中匹配，使用空格来代替标点和换行符
    # 转换成小写
    text = text.lower()
    # 生成所有词的列表
    word_list = text.split(' ')
    # 去除空白单词
    # filter(func, seq),用于提取seq中能使func为true的元素序列。是一个布尔函数
    word_list = filter(None, word_list) # 判断word_list中的字符是否为空
    # 生成单词和词频但系,就是遍历这个word_list来统计
    word_cnt = {}
    for word in word_list:
        if word not in word_cnt:
            word_cnt[word] = 0
        word_cnt[word] += 1
    # 按照词频排序
    # key 表示用于么一个列表项，reverse表示反向排序
    sorded_word_cnt = sorted(word_cnt.items(), key=lambda kv:kv[1], reverse=True)
    return sorded_word_cnt


with open('in.txt', 'r') as fin:
    text = fin.read()
word_and_freq = parse(text)
with open('out.txt', 'w') as fout:
    for word, freq in word_and_freq:
        fout.write('{} {}\n'.format(word, freq))

```
**注意：所有的I/O操作都应该进行错误处理**

## json 序列化与实战
1:json(JavaScript Object Notation)是一种轻量级的数据交换格式，把所有事情都用设计的字符串来表示。
2:函数
- json.dumps()  python基本数据类型----->序列化string
- json.loads()  字符串反序列化python的基本数据类型
## 总结
- I/O 操作需谨慎，一定要进行充分的错误处理，并细心编码，防出现漏洞
- 编码时，对内存占用的磁盘占用要有充分的估计，
- json序列化是很方便的工具

## 思考题
第一问：你能否把NLP的例子中的word count实现一遍？不过这次，in.txt可能非常非常大（意味你不能一次性读入到内存），而out.txt不是很大（意味着单词的重复很多）
第二问：百度网盘，假设空间限制（5GB），如果有一天，你计划把家里的100G的数据传送到公司，可惜你没有带U盘，于是你想到了.....

# 07 | 修炼基本功：条件与循环
https://time.geekbang.org/column/article/96597