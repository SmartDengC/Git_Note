## 1、内存页式管理方式中，首先淘汰在内存中空闲（未被修改或读取）时间最长的帧，这种替换策略是_____.（B ）

> A 先进先出（FIFO）
>
> B 最近最少使用法（LRU）
>
> C 优先级调度
>
> D 轮转法

未被修改或读取，LRU

## 2、引用和指针，下面说法不正确的是：（A）

> A: 引用和指针在声明后都有自己的内存空间
>
> B: 引用必须在声明是初始化，而指针不用
>
> C: 引用声明后，引用的对象不可改变，对象的值可以改变，指针可以随时改变指向的 对象以及对象的值。
>
> D: 空值null不能引用，而指针可以指向null。

1、内存方面：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个**别名**而已。

2、空值 **指针的值可以为空**，也可能指向一个**不确定的内存空间**，但是**引用的值不能为空**，并且引用在定义的时候必须**初始化**为特定的对象。

3、**指针**的值在初始化后**可以改变**，机制向其他的存储单元，而**引用**在初始化后就**不会在改变引用对象**了。

## 3、十大排序

排序算法的平均时间复杂度，空间复杂度，以及稳定性。

其次是最好情况和最坏情况。

![image-20200909002701818](https://gitee.com/jet5devil/typora-picture/raw/master/img/20200909002701.png)

## 4、用二进制来编码字符串“abcdabeaa”,需要能够根据编码，解码回原来的字符串，最少需要多长的二进制字符串？(C)

> A: 17
>
> B: 18
>
> C: 19
>
> D: 20

![image-20200910174509794](https://gitee.com/jet5devil/typora-picture/raw/master/img/20200910174510.png)

[【科普教室】数据压缩与哈夫曼编码（zip和jpg底层都使用到的编码方法）](https://www.bilibili.com/video/BV1dE411Z7Zw?from=search&seid=16691927451532949492)

不理解哈夫曼编码的童鞋，可以看一下这个科普视频，简单粗暴，时间也短。

## 5、TCP关闭过程中，主动关闭方不可能处于的状态（C）

> A: FIN_WAIT_1
>
> B: FIN_WAIT_2
>
> C: CLOSE_WAIT
>
> D: TIME_WAIT



CLOSE_WAIT：表示等待关闭，对方主动发送一个FIN数据包来关闭socket连接，同时本机迅速回应一个ack包，此时本机处于CLOSE_WAIT状态。

![image-20200910182159147](https://gitee.com/jet5devil/typora-picture/raw/master/img/20200910182159.png)

## 6、如下函数，在32 bit系统foo(2^31-3)的值是：

```c
int foo(int x)
 {
     return x&-x;
 }
```

> A: 0
>
> B: 1
>
> C: 2
>
> D: 4

> 2与31异或，10与11111异或后得11101，3为11，11101-11=11010
>
> -11010相当于11010取反加1为00110
>
> 11010&00110=10，结果为2

注意这里的`2^31`是2与31异或，java中2的31次方使用Math.pow(2.31);

## 7、在进程状态转换是，下列（）转换不可能 发生的。

> D: 阻塞态到运行态

![image-20200910192217044](https://gitee.com/jet5devil/typora-picture/raw/master/img/20200910192217.png)

> 引起进程状态转换的具体原因如下：
>
> - 运行态—→等待态：等待使用资源；如等待外设传输；等待人工干预。
> - 等待态—→就绪态：资源得到满足；如外设传输结束；人工干预完成。
> - 运行态—→就绪态：运行时间片到；出现有更高优先权进程。
> - 就绪态—→运行态：CPU 空闲时选择一个就绪进程。

## 11、

```c
int func(int x) { 
    int countx = 0; 
    while(x)
    {
        countx ++;
        x = x&(x-1);
    }
    return countx;
} 
如果x=254，函数的返回值为：（）
```

x = x&(x-1);//求x的二进制表达式有多少个1

x = x|(x-1);//求x的二进制表达式有多少个0

## 12、

①下面关于Linux文件 系统的软连接文件和硬链接文件，描述不正确的是（D）

```
A:软链接文件可以指向另外一个文件系统的文件
B:硬链接文件会增加被指向文件的引用计数
C:删除被指向文件时，对应的软链接文件会失效
D:删除被指向文件时，对应的硬链接文件会失效
```

②在Linux系统，关于硬链接的描述正确的是（BD）

```
A: 跨文件系统
B:不可以跨文件系统
C:为链接文件创建新的i节点
D:链接文件的i节点与被链接文件的i节点相同
```

解答：

[硬链接与软链接的区别 ]:( http://baike.baidu.com/view/4328569.htm )

  在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号inode  。**软连接，其实就是新建立一个文件**，这个文件就是专门用来指向别的文件的（那就和windows  下的快捷方式的那个文件有很接近的意味）。软链接产生的是一个新的文件，但这个文件的作用就是专门指向某个文件的，删了这个软连接文件，那就等于不需要这个连接，和原来的存在的实体原文件没有任何关系，但删除原来的文件，则相应的软连接不可用（cat那个软链接文件，则提示“没有该文件或目录“）

  **硬连接是不会建立inode的**，他只是在文件原来的inode link  count域再增加1而已，也因此**硬链接是不可以跨越文件系统的**。相反都是软连接会重新建立一个inode，当然inode的结构跟其他的不一样，他只是一个指明源文件的字符串信息。一旦删除源文件，那么软连接将变得毫无意义。而硬链接删除的时候，系统调用会检查inode  link count的数值，如果他大于等于1，那么inode不会被回收。因此文件的内容不会被删除。 

  **硬链接实际上是为文件建一个别名**，链接文件和原文件实际上是同一个文件。可以通过ls  -i来查看一下，这**两个文件的inode号是同一个**，说明它们是同一个文件；而软链接建立的是一个指向，即链接文件内的内容是指向原文件的指针，它们是两个文件。 

  软链接可以跨文件系统，硬链接不可以；软链接可以对一个不存在的文件名(filename)进行链接（当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件）,硬链接不可以（其文件必须存在，inode必须存在）；软链接可以对目录进行连接，硬链接不可以。两种链接都可以通过命令  ln 来创建。ln 默认创建的是硬链接。使用 -s 开关可以创建软链接。

## 13、下列网络知识点，描述不正确的是（D）

```
A: 字节序是一种特殊的协议，在涉及到多个字节联合解析时才有意义，所以单字节编码的ascll编码无需关注
B: rpc自带的序列化/反序列化，内部一般会处理好字节序，此时调用者无需关注字节序
C: ping 127.0.0.1，网路包并不会传递到物理网卡
D: tcp通信相比udp通信，具有可靠和有记录边界等优点
```

UDP有边界，应用层要整包地收，一次只能收一包，每次接收的要么是一个独立的完整的数据包，要么什么也接收不到。

TCP是无边界的，是字节流，需要应用层自己判断包边界，一次不一定能收几包，也不一定是完整的包。

127.0.0.1是环回地址，ip函数会直接交给环回驱动程序处理，不会经过网卡。

字节序？rpc？

## 14、

冯·诺依曼体系结构计算机必须具备五大基本组成部件，包括：输人数据和程序的输入设备、记忆程序和数据的存储器、完成数据加工处理的运算器、控制程序执行的控制器、输出处理结果的输出设备